/**
 * Copyright (c). EMS LINQ, INC.
 * All Rights Reserved.
 */

import { DateTime } from 'luxon';
import ejs from 'ejs';
import fs from 'fs';
import nodemailer from 'nodemailer';
import path from 'path';
import { readJSONSync } from 'fs-extra';

/**
 * Class to manage the creation of email html reports
 */
class EmailReportGenerator {

  private htmlTemplate = fs.readFileSync(
    path.join(process.cwd(), 'resources',
      'pipeline_email_results.ejs'), { encoding: 'utf8', flag: 'r' }
  );

  private htmlTemplateComplete = fs.readFileSync(
    path.join(process.cwd(), 'resources',
      'pipeline_email_results_complete.ejs'), { encoding: 'utf8', flag: 'r' }
  );

  /**
   * Tests if a given tag string is associated to a bug number
   * @param tag tag to test
   * @returns the found bug number
   */
  private findBugNumber(tag: string): string | null {
    const bugsRegex = /@(?<bugType>closed|documentation|product)Bug(?<number>[0-9]+)/g;
    const matches = bugsRegex.exec(tag);
    if (matches?.groups !== undefined)
      return matches.groups.number;
    return null;
  }

  /**
   * Generates an HTML report of Email Pipeline report
   * @param pipelineUrl Pipeline Url to be added in the report
   * @param pipelineExecutionNumber Number of execution
   * @param dashboardUrl Pipeline Url to be added in the report
   * @param service Name of the service for the results
   * @param title Title for the report (can be autogenerated)
   * @param bugsBaseUrl Uses this url to concat with bug numbers
   */
  async generate(
    pipelineUrl: string,
    pipelineExecutionNumber = '',
    dashboardUrl = '',
    service = 'Some Service',
    title = '',
    bugsBaseUrl = '',
  ): Promise<void> {
    const cucumberReport = readJSONSync(path.join('cucumber-report.json'));

    // getting scenarios with failed steps
    const failedData = cucumberReport.map((feature: Record<string, any>) => {
      return {
        featureName: feature.name,
        tags: feature.tags.map((tag: Record<string, any>) => tag.name),
        scenarios: feature.elements.map((scenario: Record<string, any>) => {
          return {
            name: scenario.name,
            tags: scenario.tags,
            f: scenario.steps.some(
              (step: Record<string, any>) => step.keyword !== 'After' && step.result.status === 'failed'),
            steps: scenario.steps.filter(
              (step: Record<string, any>) => step.keyword !== 'After' && step.result.status === 'failed')
              .map(
                (step: Record<string, any>) => {
                  return {
                    keyword: step.keyword,
                    name: step.name,
                    error: step.result.error_message
                  };
                }
              )
          };
        }).filter((scenario: Record<string, any>) => (scenario.f === true))
      };
    }).filter((feature: Record<string, any>) => feature.scenarios.length > 0);

    let totalScenarios = 0;
    cucumberReport.forEach((feature: Record<string, any>) => {
      totalScenarios += feature.elements.length;
    });

    const reportedErrors = [];
    let failedCount = 0;

    for (const feature of failedData) {
      for (const scenario of feature.scenarios) {
        const error: Record<string, any> = {
          feature: feature.featureName,
          scenario: scenario.name,
          error: scenario.steps[0].error,
          stepName: scenario.steps[0].name,
          keyword: scenario.steps[0].keyword,
          bugTags: [],
        };
        // getting bug tags and links
        const bugTags = [
          ...feature.tags.filter((tag: Record<string, any>) => this.findBugNumber(tag.name) !== null),
          ...scenario.tags.filter((tag: Record<string, any>) => this.findBugNumber(tag.name) !== null)
        ];
        const bug: Record<string, any> = {};
        if (bugTags.length > 0) {
          for (const bugTag of bugTags) {
           const number = this.findBugNumber(bugTag.name);
            bug.name = number;
            bug.url = `${bugsBaseUrl}/${number}`;
            error.bugTags.push(bug);
          }
        }
        failedCount++;
        reportedErrors.push(error);
      }
    }
    const reportData = {
      title: title === '' ? `${service.toUpperCase} Pipeline Execution` : title,
      date: DateTime.now().toFormat('LL/dd/yyyy'),
      pipelineUrl,
      pipelineExecutionNumber,
      pipelineExecutionUrl: `${pipelineUrl}/_build/results?buildId=${pipelineExecutionNumber}&view`,
      dashboardUrl,
      service,
      passedCount: totalScenarios - failedCount,
      failedCount: failedCount,
      imageB64: '', // change this
      errors: reportedErrors,
    };
    // generating HTML reports
    let outputFile = path.join('email_report.html');
    let html = ejs.render(this.htmlTemplate, reportData);
    fs.writeFileSync(outputFile, html);
    outputFile = path.join('email_report_complete.html');
    html = ejs.render(this.htmlTemplateComplete, reportData);
    fs.writeFileSync(outputFile, html);
    console.log(`Failed found: ${failedCount}`);
    console.log(`Total: ${totalScenarios}`);
    console.log(`Email Report generated: ${outputFile} `);
  }

  /**
   * Sends the generated report to an email using html
   * @param from Email source address
   * @param to Destination address (coma separated for multiple)
   * @param subject Email Subject
   * @param smtpSettings Smtp email settings
   * @param smtpSettings.service smtp service name (for node mailer)
   * @param smtpSettings.host Host service to use
   * @param smtpSettings.port Port number of smtp service
   * @param smtpSettings.user User for smtp authentication
   * @param smtpSettings.password Password for smtp authentication
   */
  async sendEmailAsHtml(
    from: string,
    to: string,
    subject: string,
    smtpSettings: {
      service: string,
      host: string,
      port: number,
      user: string,
      password: string,
    }): Promise<void> {
    const transporter = nodemailer.createTransport({
      service: smtpSettings.service,
      host: smtpSettings.host,
      port: smtpSettings.port,
      secure: false,
      auth: {
        user: smtpSettings.user,
        pass: smtpSettings.password
      }
    });
    const html = fs.readFileSync(path.join('email_report.html'));
    const attachments = [
      {
        filename: `${subject}_complete.html`,
        path: path.join('email_report_complete.html'),
      }
    ];
    try {
      const info = await transporter.sendMail({
        from,
        to,
        subject,
        html,
        attachments,
      });
      console.log(`Email sent from ${from} to ${to}, Id: ${info.messageId}`);
    } catch (err) {
      throw err;
    }
  }
}

export default new EmailReportGenerator();
